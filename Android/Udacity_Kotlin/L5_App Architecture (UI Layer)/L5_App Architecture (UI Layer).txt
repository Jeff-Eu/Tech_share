# L5_App Architecture (UI Layer)

* 5. What is Architecture
    * 每一次 Architecture Pattern 都有它的優缺點，MVVM也是。
    - [Code Sample - Android Architecture Blueprints](https://github.com/android/architecture-samples)
        - 同一個ap用各種Architecture Pattern來實作，值得研究：Blueprints v1 had a collection of samples that are not maintained anymore, but can still be useful. [See all project branches](https://github.com/android/architecture-samples/branches).
    - Talk - Android Jetpack: what's new in Architecture Components (Google I/O '18)
    - Talk - Droidcon NYC 2016 - A Journey Through MV Wonderland
    - Blog Post - Android Architecture Patterns Part 2: Model-View-Presenter
    - Documentation - Guide to App Architecture
Blog Post - Android and Architecture

* 6. Our App Architecture
    * UI-Controller & ViewModel & LiveData
        * UI controller is the word that I'm using to describe what activities and fragments are.
        * UI controller is responsible for any user interface related tasks

* 7. ViewModel
    * 為了解決像rotate會需要Fragment跟Activity去重建的狀況，會利用 onSaveInstanceState寫在Fragment中，如果裡面做很多複雜的事，這種寫法會變很複雜，這時候可以把這些邏輯寫進ViewModel
    * The ViewModel survives configuration changes.
    * Unlike the onSaveInstanceState bundle, the ViewModel has no restrictions on size!

* 8. Exercise: Create the GameViewModel (重要)
    * 將 Fragment 與 ViewModel 做關聯
        * You never construct ViewModels yourself.
        * If you did, you'd end up constructing a ViewModel every time the fragment was recreated,
        * which wouldn't solve our rotation issue.
        * Instead the lifecycle library creates the ViewModel for you.
    * 在 Fragment 的 onCreateView 裡面，創建 ViewModel 並與 Fragment 作關聯
        ```kotlin
        viewModel = ViewModelProviders.of(this).get(GameViewModel::class.java)
        ```
        * When ViewModelProviders is called again,
        * it'll return a reference to
        * a pre-existed GameViewModel associated with this UI controller.
    * 
        ```kotlin
        class GameViewModel : ViewModel() {

            init {
                Log.i("GameViewModel", "GameViewModel created!")
            }
            // 這會在 Fragment 被 destroy 的前後，就會被呼叫 (目前還不曉得前後順序)
            override fun onCleared() {
                super.onCleared()
                Log.i("GameViewModel", "GameViewModel destroyed!")
            }
        }
        ```
    *  Run your code, and make sure you see the expected logs. Rotate your device a few times and notice how the `GameViewModel` does not get created again.

* 9. What Belongs in the GameViewModel? 
    * What should be moved to the ViewModel? Keep in mind:
        * The ViewModel is a stable place to store the data to display in the associated UI controller.
        * The Fragment draws the data on screen and captures input events. It should not decide what to display on screen or process what happens during an input event.
        * The ViewModel never contains references to activities, fragments, or views.

* 10. Exercise: Populate the GameViewModel
    * 
        * The viewModel should never contain references to activities, fragments, or views.
        * Now, you might be wondering about the reasoning for that last rule.
        * Remember that a big reason for us using viewModels is that they survive configuration changes.
        * By nature, activities, fragments, and views don't survive configuration changes.
    * 
        * Nav controller is found by passing in a viewer fragment,
        * which are things that we do not want in the viewModel.
        * So basically, any navigation that you do is going to need to be done in the fragment.